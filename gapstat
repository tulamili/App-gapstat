#!/usr/bin/perl 
use 5.014 ; use warnings ; 
use Time::HiRes qw [ gettimeofday tv_interval ] ;
my ${ dt_start } = [ gettimeofday ] ; 
use Encode qw[ decode_utf8 encode_utf8 ] ; 
use Getopt::Std ; getopts '@:=G:L:R:u:' , \my %o  ; 
use Term::ANSIColor qw[ color :constants ] ; $Term::ANSIColor::AUTORESET = 1 ;
use FindBin qw[ $Script ] ; 
use List::Util qw[ max uniq ] ; 
use Scalar::Util qw [ dualvar ]  ;  # dualvar は num, string の順である。
use utf8 ; 

* d3 = exists $o{','} && $o{','} eq 0 ? sub{$_[0]} : sub { $_[0] =~ s/(?<=\d)(?=(\d\d\d)+($|\D))/,/gr } ;
$/ = $o{R} ? "\r\n" : "\n" ;  # 入力の改行文字に関して。Windows形式なら -R 1 が指定されることになる。
* decode = ($o{u}//'') ne 0 ? * decode_utf8 : sub ( $ ) { $_[0] } ; 
binmode STDOUT , "utf8" unless ($o{u}//'') eq 0 ;
$o{'@'} //= 15 ; # 何秒おきにアラームを発生させるか
my $help = 0  ; # オンラインヘルプの文面の表示をしたか否か。
my $readLines  ; # 読み取った行数

$SIG{INT} = sub { exit } ;
$SIG{ALRM} = sub { 
  my $n = $.  =~ s/(?<=\d)(?=(\d\d\d)+($|\D))/,/gr ; # 3桁ごとに区切る。
  say STDERR GREEN "$. lines read ($Script). " , scalar localtime ; 
  alarm $o{'@'} ;
} ; 
alarm $o{'@'} ;

my %gd ; # Gap Distribution 間隙の広さについての分布。 $gd{ gap } で 間の広さが gap であるものの、頻度を格納。
my %gdw1 ; # w = Where ; それが発生した場所の最初
my %gdw2 ; # w = Where ; それが最後に発生した場所(行番号)

# 以下の lc は、 longest chain . 
our %lc ; #  @{ $lc{Gap} } により、dualvar n,"w:s"。何個(n)続いた、何行目(w)の文字列(s)。各Gapでnは出来るだけ大きく(長く)する。
our %lc0 ; # @lc を算出するための、一時的な格納場所
my $head = <> if $o{'='} ; 
my $prev ; # 直前の行について [ $. , $str ] を格納。 ただし、[ , ] は dualvar である。
while( <> ) { 
  my $neof = 1 ; # 毎行読み取り終わった場合の、最後の処理が終わったら 1 になる。
  $_ = decode ($_) ;
  s/\s//g ; # chomp もしなくて良くなっている。
  y/０-９/0-9/ unless ($o{u}//'') eq 0 ;  
  my $gap = undef ; # 直前の行の内容数値との差分を格納する。
  if ( defined $prev ) { 
    $gap = $_ - ($prev.'') ;
    $gd { $gap } ++ ; 
    $gdw1 { $gap } //= dualvar $prev , sprintf "%s ~ %s:%s" , $prev . '' , $. , $_ ; # <-- 数段階トリッキー。
    $gdw2 { $gap }   = dualvar $prev , sprintf "%s ~ %s:%s" , $prev . '' , $. , $_ ;
  }
  next if ($o{L}//'') eq 0 ;
  my $str = $_ ; 

  if ( ! defined $gap ) { $lc0 {Inf} = dualvar 1 , "$.:$str" ; $gd {Inf} = 0 ; next }  # $. の部分は 1 でも良いかも。 <-- - 
=for comment
  if ( $gd { $gap } == 1 ) { # もしも、そのギャップの値での記録が 1 個つまり初めてだった時
    my $max = max grep { abs $gap >= $_ } map { abs $_ } keys %gd ; # max 関数の対象が空であれば、返り値は undef となる。
    $lc0 { abs $gap } = defined $max ? $lc0 { $max } : $lc0{Inf} ; # if defined $max ; 
  }
=cut
  ULOOP : 
  #for ( sort {$a<=>$b} uniq map { abs $_ } keys %gd ) { # $_ は「既存ギャップ」。 (許容ギャップという呼び名も考えたけど、使い道無しかも。)
  #for ( 0.. max grep {$_ != "Inf"} abs keys %gd  ) { 
  for ( 0 .. 30 ) { 
    #if ( $_ < abs $gap && defined $lc0 { $_ } )  { ## 各既存ギャップが直前ギャップより小なら、その各々の lc0 はlcで条件が合えば記録し、いずれの場合もリセット。
    if ( $_ < abs $gap && defined $lc0 { $_ } || $neof == 0 && defined $lc0 { $_ } )  {
      sub se($$){ dualvar $_[0] , sprintf "%s ~ %s:%s" , $_[0].'', $_[1]+0, $_[1].'' } # 関数 start end のつもり。1回しか使わないので、ここに書いた。
      my $put = se $lc0{$_}, $prev ; # $lc0{gap}で[連続長,最初の場所:最初の値] 。$prevは[$.,$_]。つまり、返り値は、[連続長,初所:初値 ~ 終所:終値]。
      if ( !defined $lc{$_} || $lc{$_}[0] < $lc0{$_} ) {  @{ $lc{$_} } = ($put)  } # $lc{$_}が存在しないか、その中身がチェーン長がlc0より短いなら、lc0で上書き。
      elsif ( $lc{$_}[0] == $lc0{$_} )  { push @{ $lc{$_} } , $put } # $lc{$_}の中身について、連続長が $lc0{$_} に等しいなら、追加する。
      delete $lc0 { $_ }  ; 
    } elsif ( $_ >= abs $gap ) {
      $lc0{$_} = defined $lc0{$_} ? dualvar 1+$lc0{$_} , $lc0{$_} : dualvar 2,  ($prev+0).":".$prev ; #"$.:$str" ;  # 0 ,
    }
  }
  $prev = dualvar $. , $_  and $neof = 0 or goto ULOOP if eof && $neof ; # and or xor は、やり過ぎかもか。
} continue {
  $prev = dualvar $. , $_ ; #
}   
& gap1output unless ($o{G}//'') eq 0 ; 
exit 0 if ($o{L}//'') eq 0 ; 

# 出力2. longest length と max gap #### 
say join "\t", map { UNDERLINE $_ }  "|gap|<=" , "lenmax" , "line:content" ; 
for ( grep { $_ != "Inf" } sort { $a <=> $b } uniq map { abs $_ } keys %gd  ) { 
  my @chains = defined $lc{$_} ? @{ $lc {$_} } : () ; # それだけの $_ つまり max abs gap を持つものの、リストを取り出す。
  my $Length = defined $chains[0] ? $chains [0] +0 : "NA" ; # 本当は(バグってなければ)、どの要素を取ってきても良い。その数値部分(dualvar) を取り出す。それは最長長さ。
  say join "\t" , $_ , $Length, map { $_ } @chains ; 
}

sub gap1output () { # 出力1. Gapsの出力 
  say join "\t", map { UNDERLINE $_ } 'gap', 'frq' , 'first' , 'prev (line:content by "start ~ end")' ; 
  for ( grep { $_ != "Inf" } sort { $a <=> $b } keys %gd ) {
    say join "\t" , $_ , $gd { $_ }, & ww ( $gdw1{$_} , $gdw2{$_} ) ; 
  }
}
# 関数 where から where 
sub ww ( $$ ) { 
  my ($n1,$n2,$w1,$w2) = ( $_[0].'' , $_[1].'' , $_[0]+0, $_[1]+0 ) ;
  return $w1 == $w2 ? "$w1:$n1" : "$w1:$n1\t$w2:$n2" ; 
}

END {
  exit if $help ;
  my $procsec = sprintf "%.5f", tv_interval ${ dt_start } ; #time - $time0 ; # このプログラムの処理にかかった秒数。比較する2個の時刻は秒単位なので、±1秒未満の誤差は発生する。
  $readLines //= $. ; # Ctrl+Cの連打で必要となる処理。
  return if ($o{2}//'') eq 0 ; 
  my $linenumeral = $readLines > 1 ? 'lines' : 'line' ; 
  print STDERR BOLD FAINT ITALIC d3 ( $readLines ) . " $linenumeral read" ; 
  my $s = tv_interval $dt_start , [ gettimeofday ] ; 
  say STDERR BOLD FAINT ITALIC " -- $Script ; " . $procsec . " seconds in process" ;
}

## ヘルプの扱い
sub VERSION_MESSAGE {}
sub HELP_MESSAGE {
  use FindBin qw[ $Script ] ; 
  $ARGV[1] //= '' ;
  open my $FH , '<' , $0 ;
  while(<$FH>){
    s/\$0/$Script/g ;
    print $_ if s/^=head1// .. s/^=cut// and $ARGV[1] =~ /^o(p(t(i(o(ns?)?)?)?)?)?$/i ? m/^\s+\-/ : 1;
  }
  close $FH ;
  exit 0 ;
}
=encoding utf8

=head1 $0 

改行区切りで数値を読み取る。主な使い方は、連番でない場所を見つける。
 * 最も大きな空き(整数の抜けている箇所)を見つける。
 * 最も長い連続した(i.e.空きのない) 数の連続を見つける。

オプション : 
 -=     : 1行目を読み飛ばす。
 -G 0   : ギャップ(間隙)の統計表を出力しない。(2番目の表示を見やすくするため)
 -L 0   ; 2番目の出力表(許容ギャップごとに数列の最大長とその例を示す)を出力しない。このことで計算量が節約出来る。
 -R 1   : 改行文字が Windows 形式 すなわち \r\n に対応。
 -u 0   : utf8と見なさない。全角の０から９までを数値と見なすことをしない(実験的であり今後の開発のために残す)。
 -@ N   : N秒おきにどこまで読み取ったかを、標準エラー出力に出力する。
 --help : このオンラインヘルプの文面を表示する。

開発メモ : 
  * 2番目の表で、ギャップが異なっても、残りが同じ表示になる場合に、一つにまとめる(大きい方のギャップの値に合わせる)ようにせよ。
  * 2番目の表が、見ただけでもちょっと不具合有り。
  * 元の表で動作をきちんと確かめよ。
  * 他の表でも確かめたい。tsvファイルで。
  * 単純な数値以外でも、eやfを使った科学的表記や、日付や時刻にも対応したい(変換関数をオプションで受け付けるようにしたい)。

=cut
