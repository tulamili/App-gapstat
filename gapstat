#!/usr/bin/perl 
use 5.014 ; use warnings ; 
use Time::HiRes qw [ gettimeofday tv_interval ] ;
my ${ dt_start } = [ gettimeofday ] ; 
use Encode qw[ decode_utf8 encode_utf8 ] ; 
use Getopt::Std ; getopts '@:=G:L:R:u:' , \my %o  ; 
use Term::ANSIColor qw[ color :constants ] ; $Term::ANSIColor::AUTORESET = 1 ;
use FindBin qw[ $Script ] ; 
use List::Util qw[ max uniq ] ; 
use Scalar::Util qw [ dualvar ]  ;  # dualvar は num, string の順である。
use utf8 ; 

* d3 = exists $o{','} && $o{','} eq 0 ? sub{$_[0]} : sub { $_[0] =~ s/(?<=\d)(?=(\d\d\d)+($|\D))/,/gr } ;
$/ = $o{R} ? "\r\n" : "\n" ;  # 入力の改行文字に関して。Windows形式なら -R 1 が指定されることになる。
* decode = ($o{u}//'') ne 0 ? * decode_utf8 : sub ( $ ) { $_[0] } ; 
binmode STDOUT , "utf8" unless ($o{u}//'') eq 0 ;
$o{'@'} //= 10 ; # 何秒おきにアラームを発生させるか
my $help = 0  ; # オンラインヘルプの文面の表示をしたか否か。
my $readLines  ; # 読み取った行数

$SIG{INT} = sub { exit } ;
$SIG{ALRM} = sub { 
  my $n = $.  =~ s/(?<=\d)(?=(\d\d\d)+($|\D))/,/gr ; # 3桁ごとに区切る。
  say STDERR GREEN "$. lines read ($Script). " , scalar localtime ; 
  alarm $o{'@'} ;
} ; 
alarm $o{'@'} ;

my %ls ; # Longgest Sequence 最も長い、間隙のない数列についての情報。(最初と最後を見たいかも)
my %bg ; # Biggest Gap 最も大きな勧化についての情報。(最初と最後を見たいかも)
my %gd ; # Gap Distribution 間隙の広さについての分布。 $gd{ gap } で 間の広さが gap であるものの、頻度を格納。
my %gdw1 ; # w = Where ; それが発生した場所の最初
my %gdw2 ; # w = Where ; それが最後に発生した場所(行番号)

# 以下の lc は、 longest chain . 
my %lc ; #  @{ $lc{ maxgap } } により、「何個n続いたか、何行目(whereのw)の文字列sが何であったかを示す。(dualvar n,"w:s"で格納)」の最長のリスト
my %lc0 ; # @lc を算出するための、一時的な格納場所

# 関数 Start End
sub se ( $$ ) { 
  return dualvar $_[1] + 0 , sprintf "%s ~ %s:%s" , $_[0] , $_[1] + 0 , $_[1] . '' ; 
}

# 関数 where から where 
sub ww ( $$ $ ) { 
  my ($n1,$n2,$w1,$w2) = ( $_[0].'' , $_[1].'' , $_[0]+0, $_[1]+0 ) ;
  return $w1 == $w2 ? "$w1:$n1" : "$w1:$n1\t$w2:$n2" ; 
}

my $head = <> if $o{'='} ; 
my $last ; # 直前の行について、dualvar形式で、 dualvar $. , $str を格納。
while( <> ) { 
  $_ = decode ($_) ;
  s/\s//g ; # chomp もしなくてよくなる。
  y/０-９/0-9/ unless ($o{u}//'') eq 0 ;  
  next if ! defined $last ;
  my $gap = $_ - ($last.'') ;
  $gd { $gap } ++ ; 
  $gdw1 { $gap } //= dualvar $last + 0  , sprintf "%s ~ %s:%s" , $last . '' , $. , $_ ; # <-- 数段階トリッキー。
  $gdw2 { $gap }   = dualvar $last + 0  , sprintf "%s ~ %s:%s" , $last . '' , $. , $_ ;
  next if ($o{L}//'') eq 0 ;
  my $str = $_ ; 
  for ( uniq map { abs $_ } keys %gd  ) { # $_ は「許容ギャップ」 となる。(間隙の絶対値)
    if ( abs $gap > $_ && defined $lc0 { $_ } ) 
    {
      my $nondel = 0 ;
      my $put = se ( $lc0 { $_ } , $last ) if defined $lc0 { $_ } ; 
      if ( ! defined $lc { $_ } || $lc { $_ } [ 0 ] < $lc0 { $_ } ) { @{ $lc { $_ } } = ($put) } # $lc0 { $_ } 
      elsif ( $lc { $_ } [ 0 ] == $lc0 { $_ } )  { push @{ $lc { $_ } } , $put } 
      else { $nondel = 1 }
      $lc0 { $_ } = undef if $nondel == 0 ; 
    } 
    else
    {
      $lc0 { $_ } = dualvar 0 , "$.:$str" if ! defined $lc0 { $_ } ; 
      $lc0 { $_ } = dualvar 1 + $lc0 { $_ } , ''. $lc0 { $_ } ; # 前の行の本体が実行されて、数値として 0 の場合は 1になる。
    }
  }
} continue {
  $last = dualvar $. , $_ ; #$_ ;
} 

& gap1output unless ($o{G}//'') eq 0 ; 
exit 0 if ($o{L}//'') eq 0 ; 
# 出力2. longest length と max gap 
say join "\t", map { UNDERLINE $_ }  "|gap|<=" , "lenmax" , "line:content" ; 
for ( sort { $a <=> $b } uniq map { abs $_ } keys %gd  ) { 
  my @chains = defined $lc{$_} ? @{ $lc {$_} } : () ; # それだけの $_ つまり max abs gap を持つものの、リストを取り出す。
  my $Length = defined $chains[0] ? $chains [0] + 0 : "NA" ; # 本当は(バグってなければ)、どの要素を取ってきても良い。その数値部分(dualvar) を取り出す。それは最長長さ。
  say join "\t" , $_ , $Length, map { $_ } @chains ; 
}

sub gap1output () { # 出力1. Gapsの出力 
  say join "\t", map { UNDERLINE $_ } 'gap', 'frq' , 'first' , 'last (line:content by "start ~ end")' ; 
  for ( sort { $a <=> $b } keys %gd ) {
    say join "\t" , $_ , $gd { $_ }, & ww ( $gdw1{$_} , $gdw2{$_} , $_ ) ; 
  }
}

END {
  exit if $help ;
  my $procsec = sprintf "%.5f", tv_interval ${ dt_start } ; #time - $time0 ; # このプログラムの処理にかかった秒数。比較する2個の時刻は秒単位なので、±1秒未満の誤差は発生する。
  $readLines //= $. ; # Ctrl+Cの連打で必要となる処理。
  return if ($o{2}//'') eq 0 ; 
  my $linenumeral = $readLines > 1 ? 'lines' : 'line' ; 
  print STDERR BOLD FAINT ITALIC d3 ( $readLines ) . " $linenumeral read" ; 
  my $s = tv_interval $dt_start , [ gettimeofday ] ; 
  say STDERR BOLD FAINT ITALIC " -- $Script ; " . $procsec . " seconds in process" ;
}

## ヘルプの扱い
sub VERSION_MESSAGE {}
sub HELP_MESSAGE {
  use FindBin qw[ $Script ] ; 
  $ARGV[1] //= '' ;
  open my $FH , '<' , $0 ;
  while(<$FH>){
    s/\$0/$Script/g ;
    print $_ if s/^=head1// .. s/^=cut// and $ARGV[1] =~ /^o(p(t(i(o(ns?)?)?)?)?)?$/i ? m/^\s+\-/ : 1;
  }
  close $FH ;
  exit 0 ;
}
=encoding utf8

=head1 $0 

改行区切りで数値を読み取る。主な使い方は、連番でない場所を見つける。
 * 最も大きな空き(整数の抜けている箇所)を見つける。
 * 開いたところの最初と最後を見つける。
 * 最も長い連続した(i.e.空きのない) 数の連続を見つける。

オプション : 

 -=     : 1行目を読み飛ばす。
 -G 0   : ギャップ(間隙)の統計表を出力しない。(2番目の表示を見やすくするため)
 -L 0   ; 2番目の出力表(許容ギャップごとに数列の最大長とその例を示す)を出力しない。このことで計算量が節約出来る。
 -R 1   : 改行文字が Windows 形式 すなわち \r\n に対応。
 -u 0   : utf8と見なさない。全角の０から９までを数値と見なすことをしない(実験的であり今後の開発のために残す)。
 -@ N   : N秒おきにどこまで読み取ったかを、標準エラー出力に出力する。

開発メモ : 
  * 2番目の表で、ギャップが異なっても、残りが同じ表示になる場合に、一つにまとめる(大きい方のギャップの値に合わせる)ようにせよ。
  * 2番目の表が、見ただけでもちょっと不具合有り。
  * 元の表で動作をきちんと確かめよ。
  * 他の表でも確かめたい。tsvファイルで。
  * 単純な数値以外でも、eやfを使った科学的表記や、日付や時刻にも対応したい(変換関数をオプションで受け付けるようにしたい)。

=cut
